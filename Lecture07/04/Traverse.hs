{-
  Обход графа в ширину
-}
module Traverse where

-- Функциональное представление графа:
-- (число вершин, функция смежности)
type Graph = (Int, (Int->Int->Bool))
-- Функциональное представление множества (номеров вершин)
type Set    = Int -> Bool

-- Пустое множество
empty :: Set
empty e = False

-- Операции над множествами: объединение и разность
(+++), (-=-) :: Set -> Set -> Set
(s1 +++ s2) e = s1 e || s2 e
(s1 -=- s2) e = s1 e && not (s2 e)

-- Представление множества в виде списка
-- Первый аргумент - максимально возможное значение в множестве
list :: Int -> Set -> [Int]
list n s = filter s [1..n]

-- Проверка множества на пустоту
-- Первый аргумент - максимально возможное значение в множестве
isEmpty :: Int -> Set -> Bool
isEmpty n s = null (list n s)

-- Вычисление множества вершин графа, смежных с данной
neib :: Int -> Graph -> Set
neib i (n, f) = f i

-- Вычисление списка вершин графа, смежных с данной
neighbors :: Int -> Graph -> [Int]
neighbors i (n, f) = list n (f i)

-- Обход графа в ширину.
-- Аргументы:
--    - начальная вершина
--    - граф
-- Результат:
--    - множество достижимых из начальной вершин
traverse :: Int -> Graph -> Set
traverse i (n, f) = trav empty (==i) where
  -- Функция trav реализует обход в ширину
  -- Аргументы:
  --    - множество уже пройденных вершин
  --    - множество, составляющее "фронт волны"
  -- Результат:
  --    - множество всех достижимых вершин из вершин "фронта"
  trav passed front =
    if isEmpty n front
      then empty       -- Фронт пустой - достижимых вершин нет
      else front +++
           trav newPassed
                -- новый фронт - это объединение множеств всех соседей вершин из фронта
                -- за исключением самого фронта и уже пройденных ранее вершин
                ((foldr (+++) empty (map f (list n front))) -=- newPassed)
         where newPassed = passed +++ front  -- добавляем фронт в множество пройденных вершин

-- Тесты:
-- граф из 6 вершин и 6 дуг: из вершины 1 достижимы вершины [3,4,5];
--                           из вершины 2 достижима только [6]
gr :: Graph
gr = (6, f) where
   f a b | a > b = f b a
   f a b = elem (a,b) [(1,3), (1,4), (1,5), (2,6), (3,5), (4,5)]
   
testGr = (list 6 $ traverse 1 gr, list 6 $ traverse 2 gr)

-- граф из 100 вершин, разбитых на 3 полных подграфа из вершин с номерами 1-33, 34-66 и 67-100
-- из любой вершины достижимы только вершины "своего" подграфа
tank :: Graph
tank = (100, \i j -> (i >= 1 && i <= 33 && j >= 1 && j <= 33) ||
                     (i >= 34 && i <= 66 && j >= 34 && j <= 66) ||
                     (i >= 67 && i <= 100 && j >= 67 && j <= 100))
testTank = (length $ list 100 $ traverse 3 tank,
            length $ list 100 $ traverse 55 tank,
            length $ list 100 $ traverse 100 tank)